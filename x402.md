# Welcome to x402

x402 is the open payment standard that enables services to charge for access to their APIs and content directly over HTTP. It is built around the HTTP `402 Payment Required` status code and allows clients to programmatically pay for resources without accounts, sessions, or credential management.

With x402, any web service can require payment before serving a response, using crypto-native payments for speed, privacy, and efficiency.

**Want to contribute to our docs?** [The GitBook repo is open to PRs! ](https://github.com/murrlincoln/x402-gitbook) Our only ask is that you keep these docs as a neutral resource, with no branded content other than linking out to other resources where appropriate.&#x20;

**Note about the docs:** These docs are the credibly neutral source of truth for x402, as x402 is a completely open standard under the Apache-2.0 license. Coinbase Developer Platform is currently sponsoring [AI-powered docs for users here](https://docs.cdp.coinbase.com/x402/welcome), as we migrate to our own AI-powered solution on the main x402.org domain.

### Why Use x402?

x402 addresses key limitations of existing payment systems:

* **High fees and friction** with traditional credit cards and fiat payment processors
* **Incompatibility with machine-to-machine payments**, such as AI agents
* **Lack of support for micropayments**, making it difficult to monetize usage-based services

### Who is x402 for?

* **Sellers:** Service providers who want to monetize their APIs or content. x402 enables direct, programmatic payments from clients with minimal setup.
* **Buyers:** Human developers and AI agents seeking to access paid services without accounts or manual payment flows.

Both sellers and buyers interact directly through HTTP requests, with payment handled transparently through the protocol.

### What Can You Build?

x402 enables a range of use cases, including:

* API services paid per request
* AI agents that autonomously pay for API access
* [Paywalls](https://x.com/MurrLincoln/status/1935406976881803601) for digital content
* Microservices and tooling monetized via microtransactions
* Proxy services that aggregate and resell API capabilities

### How Does It Work?

At a high level, the flow is simple:

1. A buyer requests a resource from a server.
2. If payment is required, the server responds with `402 Payment Required`, including payment instructions.
3. The buyer prepares and submits a payment payload.
4. The server verifies and settles the payment using an x402 facilitator's /verify and /settle endpoints.
5. If payment is valid, the server provides the requested resource.

For more detail, see:

* Client / Server
* Facilitator
* HTTP 402

### Roadmap

x402 is designed as an open standard, and we're excited to build x402 alongside our community. Some items in the [roadmap](https://github.com/coinbase/x402/blob/main/README.md) we're excited about include:

* [ ] &#x20;Solutions guides and templates for proxy servers and tools to make an x402 integration as easy as possible
* [ ] `exact` scheme support on Solana (SVM)
* [ ] `upto` scheme EVM & SVM
* [ ] easier semantics for arbitrary tokens using permit as an alt method to `transferWithAuthorization` (likely via `permit` and an up to scheme)
* [ ] Arbitrary token support
* [ ] Production-ready marketplace and reputation system for x402-compatible endpoints

The goal is to make programmatic commerce accessible, permissionless, and developer-friendly.

### Get Started

Ready to build? Start here:

* [Quickstart for Sellers](https://x402.gitbook.io/x402/getting-started/quickstart-for-sellers)
* [Quickstart for Buyers](https://x402.gitbook.io/x402/getting-started/quickstart-for-buyers)
* [Explore Core Concepts](https://x402.gitbook.io/x402/core-concepts)
* [Join our community on Discord](https://discord.gg/invite/cdp)


# Quickstart for Buyers

This guide walks you through how to use **x402** to interact with services that require payment. By the end of this guide, you will be able to programmatically discover payment requirements, complete a payment, and access a paid resource.

### Prerequisites

Before you begin, ensure you have:

* A crypto wallet with USDC (any EVM-compatible wallet)
* [Node.js](https://nodejs.org/en) and npm, or Python and pip
* A service that requires payment via x402

**Note**\
We have pre-configured [examples available in our repo](https://github.com/coinbase/x402/tree/main/examples), including examples for fetch, Axios, and MCP.

### 1. Install Dependencies

{% tabs %}
{% tab title="Node.js" %}
**HTTP Clients (Axios/Fetch)** Install [x402-axios](https://www.npmjs.com/package/x402-axios) or [x402-fetch](https://www.npmjs.com/package/x402-fetch):

```bash
npm install x402-axios
# or
npm install x402-fetch
```

**MCP (Unofficial)** This [community package](https://github.com/ethanniser/x402-mcp) showcases how AI agents can use Model Context Protocol (MCP) with x402. We're working on enshrining an official MCP spec in x402 soon.

Install the required packages for MCP support:

```bash
npm install x402-mcp ai @modelcontextprotocol/sdk
```

{% endtab %}

{% tab title="Python" %}
Install the [x402 package](https://pypi.org/project/x402/)

```
pip install x402
```

{% endtab %}
{% endtabs %}

### 2. Create a Wallet Client

#### Create a Wallet Client

{% tabs %}
{% tab title="Node.js (viem)" %}
Install the required package:

```bash
npm install viem
```

Then instantiate the wallet account:

```typescript
import { createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";

// Create a wallet client (using your private key)
const account = privateKeyToAccount("0xYourPrivateKey"); // we recommend using an environment variable for this
```

{% endtab %}

{% tab title="Python (eth-account)" %}
Install the required package:

```bash
pip install eth_account
```

Then instantiate the wallet account:

```python
from eth_account import Account

account = Account.from_key("your_private_key") # we recommend using an environment variable for this
```

{% endtab %}
{% endtabs %}

#### Solana (SVM)

Use [SolanaKit](https://www.solanakit.com/) to instantiate a signer:

```typescript
import { createKeyPairSignerFromBytes } from "@solana/kit";
import { base58 } from "@scure/base";

// 64-byte base58 secret key (private + public)
const signer = await createKeyPairSignerFromBytes(
  base58.decode(process.env.SOLANA_PRIVATE_KEY!)
);
```

### 3. Make Paid Requests Automatically

#### Node.js

You can use either `x402-fetch` or `x402-axios` to automatically handle 402 Payment Required responses and complete payment flows.

{% tabs %}
{% tab title="Fetch" %}
**x402-fetch** extends the native `fetch` API to handle 402 responses and payment headers for you. [Full example here](https://github.com/coinbase/x402/tree/main/examples/typescript/clients/fetch)

```typescript
import { wrapFetchWithPayment, decodeXPaymentResponse } from "x402-fetch";
// other imports...

// wallet creation logic...

const fetchWithPayment = wrapFetchWithPayment(fetch, account);

fetchWithPayment(url, { //url should be something like https://api.example.com/paid-endpoint
  method: "GET",
})
  .then(async response => {
    const body = await response.json();
    console.log(body);

    const paymentResponse = decodeXPaymentResponse(response.headers.get("x-payment-response")!);
    console.log(paymentResponse);
  })
  .catch(error => {
    console.error(error.response?.data?.error);
  });
```

{% endtab %}

{% tab title="Axios" %}
**x402-axios** adds a payment interceptor to Axios, so your requests are retried with payment headers automatically. [Full example here](https://github.com/coinbase/x402/tree/main/examples/typescript/clients/axios)

```typescript
import { withPaymentInterceptor, decodeXPaymentResponse } from "x402-axios";
import axios from "axios";
// other imports...

// wallet creation logic...

// Create an Axios instance with payment handling
const api = withPaymentInterceptor(
  axios.create({
    baseURL, // e.g. https://api.example.com
  }),
  account,
);

api
  .get(endpointPath) // e.g. /paid-endpoint
  .then(response => {
    console.log(response.data);

    const paymentResponse = decodeXPaymentResponse(response.headers["x-payment-response"]);
    console.log(paymentResponse);
  })
  .catch(error => {
    console.error(error.response?.data?.error);
  });
```

{% endtab %}

{% tab title="x402-mcp" %}
**x402-mcp** provides payment handling for MCP clients, allowing AI agents to automatically pay for tools. [Full example here](https://github.com/ethanniser/x402-mcp/tree/main/apps/example)

```typescript
import { convertToModelMessages, stepCountIs, streamText } from "ai";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { experimental_createMCPClient as createMCPClient } from "ai";
import { withPayment } from "x402-mcp";

// Create MCP client with payment capabilities
const mcpClient = await createMCPClient({
  transport: new StreamableHTTPClientTransport(mcpServerUrl), // URL of your MCP server
}).then((client) => withPayment(client, {
  account, // Your wallet account from step 2
  network: "base" // or "base-sepolia" for testnet
}));

// Get available tools (both paid and free)
const tools = await mcpClient.tools();

// Use the tools with your AI model
const result = streamText({
  model: "gpt-4", // or any AI model
  tools,
  messages: convertToModelMessages(messages),
  stopWhen: stepCountIs(5), // Limit tool calls for safety
  onFinish: async () => {
    await mcpClient.close();
  },
  system: "ALWAYS prompt the user to confirm before authorizing payments",
});
```

**Features:**

* Automatically detects when MCP tools require payment
* Handles x402 payment flow transparently
* Supports both paid and free tools from the same server
* Integrates seamlessly with Vercel AI SDK

**Note:** The `withPayment` wrapper adds payment capabilities to any MCP client. When a tool call requires payment, it will automatically handle the x402 payment flow using your configured wallet.
{% endtab %}
{% endtabs %}

#### Python

You can use either `httpx` or `Requests` to automatically handle 402 Payment Required responses and complete payment flows.

* **Requests** is a well-established library for **synchronous** HTTP requests. It is simple and ideal for straightforward, sequential workflows.
* **HTTPX** is a modern library that supports both **synchronous** and **asynchronous** (async) HTTP requests. Use HTTPX if you need high concurrency, advanced features like HTTP/2, or want to leverage Python’s async capabilities

Both support a **simple** and **extensible** approach. The simple returns a pre-configured client that handles payments automatically, while the extensible lets you use an existing session/client. The simple is covered here, while the extensible is in the README of the full examples linked below.

{% tabs %}
{% tab title="HTTPX" %}
[Full example here](https://github.com/coinbase/x402/tree/main/examples/python/clients/httpx)

<pre class="language-python"><code class="lang-python">from x402.clients.httpx import x402HttpxClient
# Other imports...

# Wallet creation logic ...

<strong># Create client and make request
</strong>async with x402HttpxClient(account=account, base_url="https://api.example.com") as client:
    response = await client.get("/protected-endpoint")
    print(await response.aread())
</code></pre>

{% endtab %}

{% tab title="Requests" %}
[Full example here](https://github.com/coinbase/x402/tree/main/examples/python/clients/requests)

<pre class="language-python"><code class="lang-python">from x402.clients.requests import x402_requests
# Other imports...

# Wallet creation logic ...

<strong># Create session and make request
</strong>session = x402_requests(account)
response = session.get("https://api.example.com/protected-endpoint")
print(response.content)
</code></pre>

{% endtab %}
{% endtabs %}

### 4. Error Handling

Clients will throw errors if:

* The request configuration is missing
* A payment has already been attempted for the request
* There is an error creating the payment header

### Summary

* Install an x402 client package
* Create a wallet client
* Use the provided wrapper/interceptor to make paid API requests
* Payment flows are handled automatically for you

***

**References:**

* [x402-fetch npm docs](https://www.npmjs.com/package/x402-fetch)
* [x402-axios npm docs](https://www.npmjs.com/package/x402-axios)
* [x402 PyPi page](https://pypi.org/project/x402/)

For questions or support, join our [Discord](https://discord.gg/invite/cdp).

# Quickstart for Sellers

This guide walks you through integrating with **x402** to enable payments for your API or service. By the end, your API will be able to charge buyers and AI agents for access.

### Prerequisites

Before you begin, ensure you have:

* A crypto wallet to receive funds (any EVM-compatible wallet)
* [Node.js](https://nodejs.org/en) and npm (or Python and pip) installed
* An existing API or server

**Note**\
We have pre-configured examples available in our repo for both [Node.js](https://github.com/coinbase/x402/tree/main/examples/typescript/servers) and [Python](https://github.com/coinbase/x402/tree/main/examples/python/servers). We also have an [advanced example](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/advanced) that shows how to use the x402 SDKs to build a more complex payment flow.

### 1. Install Dependencies

#### Node.js

{% tabs %}
{% tab title="Express" %}
Install the [x402 Express middleware package](https://www.npmjs.com/package/x402-express).

```bash
npm install x402-express
npm install @coinbase/x402 # for the mainnet facilitator
```

{% endtab %}

{% tab title="Next.js" %}
Install the [x402 Next.js middleware package](https://www.npmjs.com/package/x402-next).

```bash
npm install x402-next
npm install @coinbase/x402 # for the mainnet facilitator
```

{% endtab %}

{% tab title="Hono" %}
Install the [x402 Hono middleware package](https://www.npmjs.com/package/x402-hono).

```bash
npm install x402-hono
npm install @coinbase/x402 # for the mainnet facilitator
```

{% endtab %}

{% tab title="MCP (Unofficial)" %}
This [community package](https://github.com/ethanniser/x402-mcp) showcases how you can use MCP (Model Context Protocol) with x402. We're working on enshrining an official MCP spec in x402 soon.

Install the [x402-mcp package](https://www.npmjs.com/package/x402-mcp):

```bash
npm install x402-mcp
npm install @coinbase/x402 # for the mainnet facilitator
```

Full example in the repo [here](https://github.com/ethanniser/x402-mcp/tree/main/apps/example).
{% endtab %}
{% endtabs %}

#### Python

{% tabs %}
{% tab title="FastAPI/Flask" %}
[Install the x402 Python package](https://x402.gitbook.io/x402/readme)

```bash
pip install x402
pip install cdp # for the mainnet facilitator
```

{% endtab %}
{% endtabs %}

### 2. Add Payment Middleware

Integrate the payment middleware into your application. You will need to provide:

* The Facilitator URL or facilitator object. For testing, use `https://x402.org/facilitator` which works on Base Sepolia and Solana devnet.
  * For more information on running in production on mainnet, check out [CDP's Quickstart for Sellers](https://docs.cdp.coinbase.com/x402/docs/quickstart-sellers)
* The routes you want to protect.
* Your receiving wallet address.

{% tabs %}
{% tab title="Express" %}
Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/express).

```javascript
import express from "express";
import { paymentMiddleware, Network } from "x402-express";

const app = express();

app.use(paymentMiddleware(
  "0xYourAddress", // your receiving wallet address
  {  // Route configurations for protected endpoints
      "GET /weather": {
        // USDC amount in dollars
        price: "$0.001",
        network: "base-sepolia",
      },
    },
  {
    url: "https://x402.org/facilitator", // Facilitator URL for Base Sepolia testnet.
  }
));

// Implement your route
app.get("/weather", (req, res) => {
  res.send({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });
});

app.listen(4021, () => {
  console.log(`Server listening at http://localhost:4021`);
});
```

{% endtab %}

{% tab title="Next.js" %}
Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/fullstack/next). Since this is a fullstack example, we recommend using the example to build this yourself, and treat the code snippet below as a reference.

```javascript
import { paymentMiddleware, Network } from 'x402-next';

// Configure the payment middleware
export const middleware = paymentMiddleware(
  "0xYourAddress", // your receiving wallet address
  {  // Route configurations for protected endpoints
    '/protected': {
      price: '$0.01',
      network: "base-sepolia",
      config: {
        description: 'Access to protected content'
      }
    },
  }
  {
    url: "https://x402.org/facilitator", // Facilitator URL for Base Sepolia testnet.
  }
);

// Configure which paths the middleware should run on
export const config = {
  matcher: [
    '/protected/:path*',
  ]
};
```

{% endtab %}

{% tab title="Hono" %}
Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/express).

```javascript
import { Hono } from "hono";
import { serve } from "@hono/node-server";
import { paymentMiddleware, Network } from "x402-hono";

const app = new Hono();

// Configure the payment middleware
app.use(paymentMiddleware(
  "0xYourAddress", // your receiving wallet address
  {  // Route configurations for protected endpoints
    "/protected-route": {
      price: "$0.10",
      network: "base-sepolia",
      config: {
        description: "Access to premium content",
      }
    }
  },
  {
    url: "https://x402.org/facilitator", // Facilitator URL for Base Sepolia testnet.
  }
));

// Implement your route
app.get("/protected-route", (c) => {
  return c.json({ message: "This content is behind a paywall" });
});

serve({
  fetch: app.fetch,
  port: 3000
});
```

{% endtab %}

{% tab title="MCP (Unofficial)" %}
This creates an MCP server endpoint that exposes paid tools to AI agents. The tools automatically handle x402 payment requirements when called.

```javascript
import { createPaidMcpHandler } from "x402-mcp";
import z from "zod";
// import { facilitator } from "@coinbase/x402"; // For mainnet

const handler = createPaidMcpHandler(
  (server) => {
    server.paidTool(
      "get_random_number",
      "Get a random number between two numbers",
      { price: 0.001 }, // Price in USD
      {
        min: z.number().int().describe("Minimum value"),
        max: z.number().int().describe("Maximum value"),
      },
      {},
      async (args) => {
        const randomNumber =
          Math.floor(Math.random() * (args.max - args.min + 1)) + args.min;
        return {
          content: [{ type: "text", text: randomNumber.toString() }],
        };
      }
    );

    // Add more paid tools as needed
    server.paidTool(
      "premium_feature",
      "Access premium functionality",
      { price: 0.01 },
      {
        input: z.string(),
      },
      {},
      async (args) => {
        // Your premium feature logic
        return {
          content: [{ type: "text", text: "Premium result" }],
        };
      }
    );
  },
  {
    serverInfo: {
      name: "your-mcp-server",
      version: "1.0.0",
    },
  },
  {
    recipient: "0xYourAddress", // Your receiving wallet address
    facilitator,
    // network: "base-sepolia", // For testnet, "base" for mainnet
  }
);

export { handler as GET, handler as POST };
```

{% endtab %}

{% tab title="FastAPI" %}
Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/python/servers/fastapi).

```python
import os
from typing import Any, Dict

from dotenv import load_dotenv
from fastapi import FastAPI
from x402.fastapi.middleware import require_payment
from x402.types import EIP712Domain, TokenAmount, TokenAsset

# Load environment variables
load_dotenv()

app = FastAPI()

# Apply payment middleware to specific routes
app.middleware("http")(
    require_payment(
        path="/weather",
        price="$0.001",
        pay_to_address="0xAddress",
        network="base-sepolia",
    )
)

@app.get("/weather")
async def get_weather() -> Dict[str, Any]:
    return {
        "report": {
            "weather": "sunny",
            "temperature": 70,
        }
    }

```

{% endtab %}

{% tab title="Flask" %}
Full example in the repo [here](https://github.com/coinbase/x402/tree/main/examples/python/servers/flask).

```python
import os
from flask import Flask, jsonify
from dotenv import load_dotenv
from x402.flask.middleware import PaymentMiddleware
from x402.types import EIP712Domain, TokenAmount, TokenAsset

app = Flask(__name__)

# Initialize payment middleware
payment_middleware = PaymentMiddleware(app)

# Apply payment middleware to specific routes
payment_middleware.add(
    path="/weather",
    price="$0.001",
    pay_to_address="0xAddress",
    network="base-sepolia",
)
```

{% endtab %}
{% endtabs %}

This is the interface for the payment middleware config:

```typescript
interface PaymentMiddlewareConfig {
  description?: string;               // Description of the payment
  mimeType?: string;                  // MIME type of the resource
  maxTimeoutSeconds?: number;         // Maximum time for payment (default: 60)
  outputSchema?: Record; // JSON schema for the response
  customPaywallHtml?: string;         // Custom HTML for the paywall
  resource?: string;                  // Resource URL (defaults to request URL)
}
```

When a request is made to this route without payment, your server will respond with the HTTP 402 Payment Required code and payment instructions.

### 3. Test Your Integration

To verify:

1. Make a request to your endpoint (e.g., `curl http://localhost:3000/your-endpoint`).
2. The server responds with a 402 Payment Required, including payment instructions in the body.
3. Complete the payment using a compatible client, wallet, or automated agent. This typically involves signing a payment payload, which is handled by the client SDK detailed in the Quickstart for Buyers.
4. Retry the request, this time including the `X-PAYMENT` header containing the cryptographic proof of payment (payment payload).
5. The server verifies the payment via the facilitator and, if valid, returns your actual API response (e.g., `{ "data": "Your paid API response." }`).

### 4. Error Handling

* If you get an error stating `Cannot find module 'x402-hono/express' or its corresponding type declarations.`, add the tsconfig.json from the [Hono example](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/express) to your project.
* `npm install` the dependencies in each example

### Next Steps

* Looking for something more advanced? Check out the [Advanced Example](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/advanced)
* Get started as a buyer

For questions or support, join our [Discord](https://discord.gg/invite/cdp).

### Summary

This quickstart covered:

* Installing the x402 SDK and relevant middleware
* Adding payment middleware to your API and configuring it
* Testing your integration

Your API is now ready to accept crypto payments through x402.
# HTTP 402

For decades, HTTP 402 Payment Required has been reserved for future use. x402 unlocks it, and [absolves the internet of its original sin](https://economyofbits.substack.com/p/marc-andreessens-original-sin).

### What is HTTP 402?

[HTTP 402](https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.2) is a standard, but rarely used, HTTP response status code indicating that payment is required to access a resource.

In x402, this status code is activated to:

* Inform clients (buyers or agents) that payment is required.
* Communicate the details of the payment, such as amount, currency, and destination address.
* Provide the information necessary to complete the payment programmatically.

### Why x402 Uses HTTP 402

The primary purpose of HTTP 402 is to enable frictionless, API-native payments for accessing web resources, especially for:

* Machine-to-machine (M2M) payments (e.g., AI agents).
* Pay-per-use models such as API calls or paywalled content.
* Micropayments without account creation or traditional payment rails.

Using the 402 status code keeps x402 protocol natively web-compatible and easy to integrate into any HTTP-based service.

### Summary

HTTP 402 is the foundation of the x402 protocol, enabling services to declare payment requirements directly within HTTP responses. It:

* Signals payment is required
* Communicates necessary payment details
* Integrates seamlessly with standard HTTP workflows

# Client / Server

This page explains the roles and responsibilities of the **client** and **server** in the x402 protocol.

Understanding these roles is essential to designing, building, or integrating services that use x402 for programmatic payments.

**Note**\
Client refers to the technical component making an HTTP request. In practice, this is often the *buyer* of the resource.

Server refers to the technical component responding to the request. In practice, this is typically the *seller* of the resource

### Client Role

The client is the entity that initiates a request to access a paid resource.

Clients can include:

* Human-operated applications
* Autonomous agents
* Programmatic services acting on behalf of users or systems

#### Responsibilities

* **Initiate requests:** Send an HTTP request to the resource server.
* **Handle payment requirements:** Read the `402 Payment Required` response and extract payment details.
* **Prepare payment payload:** Use the provided payment requirements to construct a valid payment payload.
* **Resubmit request with payment:** Retry the request with the `X-PAYMENT` header containing the signed payment payload.

Clients do not need to manage accounts, credentials, or session tokens beyond their crypto wallet. All interactions are stateless and occur over standard HTTP requests.

### Server Role

The server is the resource provider enforcing payment for access to its services.

Servers can include:

* API services
* Content providers
* Any HTTP-accessible resource requiring monetization

#### Responsibilities

* **Define payment requirements:** Respond to unauthenticated requests with an HTTP `402 Payment Required`, including all necessary payment details in the response body.
* **Verify payment payloads:** Validate incoming payment payloads, either locally or by using a facilitator service.
* **Settle transactions:** Upon successful verification, submit the payment for settlement.
* **Provide the resource:** Once payment is confirmed, return the requested resource to the client.

Servers do not need to manage client identities or maintain session state. Verification and settlement are handled per request.

### Communication Flow

The typical flow between a client and a server in the x402 protocol is as follows:

1. **Client initiates request** to the server for a paid resource.
2. **Server responds with `402 Payment Required`**, including the payment requirements in the response body.
3. **Client prepares and submits a payment payload** based on the provided requirements.
4. **Server verifies the payment payload**, either locally or through a facilitator service.
5. **Server settles the payment** and confirms transaction completion.
6. **Server responds with the requested resource**, assuming payment was successful.

### Summary

In the x402 protocol:

* The **client** requests resources and supplies the signed payment payload.
* The **server** enforces payment requirements, verifies transactions, and provides the resource upon successful payment.

This interaction is stateless, HTTP-native, and compatible with both human applications and automated agents.

Next, explore:

* [Facilitator](https://x402.gitbook.io/x402/core-concepts/facilitator) — how servers verify and settle payments
* [HTTP 402](https://x402.gitbook.io/x402/core-concepts/http-402) — how servers communicate payment requirements to clients

# Facilitator

This page explains the role of the **facilitator** in the x402 protocol.

The facilitator is an optional but recommended service that simplifies the process of verifying and settling payments between clients (buyers) and servers (sellers).

### What is a Facilitator?

The facilitator is a service that:

* Verifies payment payloads submitted by clients.
* Settles payments on the blockchain on behalf of servers.

By using a facilitator, servers do not need to maintain direct blockchain connectivity or implement payment verification logic themselves. This reduces operational complexity and ensures accurate, real-time validation of transactions.

### Facilitator Responsibilities

* **Verify payments:** Confirm that the client's payment payload meets the server's declared payment requirements.
* **Settle payments:** Submit validated payments to the blockchain and monitor for confirmation.
* **Provide responses:** Return verification and settlement results to the server, allowing the server to decide whether to fulfill the client's request.

The facilitator does not hold funds or act as a custodian - it performs verification and execution of onchain transactions based on signed payloads provided by clients.

### Why Use a Facilitator?

Using a facilitator provides:

* **Reduced operational complexity:** Servers do not need to interact directly with blockchain nodes.
* **Protocol consistency:** Standardized verification and settlement flows across services.
* **Faster integration:** Services can start accepting payments with minimal blockchain-specific development.

While it is possible to implement verification and settlement locally, using a facilitator accelerates adoption and ensures correct protocol behavior.

### Live Facilitators

1. Currently, CDP hosts a facilitator live on Base mainnet. For more information about getting started, see the [CDP Docs](https://docs.cdp.coinbase.com/x402/docs/welcome).

* CDP's facilitator offers fee-free USDC settlement on Base mainnet

2. PayAI [hosts a facilitator](https://facilitator.payai.network) on Solana, Base, Polygon, and more. More info & docs at <https://docs.payai.network/x402>.

### Interaction Flow

1. `Client` makes an HTTP request to a `resource server`
2. `Resource server` responds with a `402 Payment Required` status and a `Payment Required Response` JSON object in the response body.
3. `Client` selects one of the `paymentDetails` returned by the `accepts` field of the server response and creates a `Payment Payload` based on the `scheme` of the `paymentDetails` they have selected.
4. `Client` sends the HTTP request with the `X-PAYMENT` header containing the `Payment Payload` to the `resource server`
5. `Resource server` verifies the `Payment Payload` is valid either via local verification or by POSTing the `Payment Payload` and `Payment Details` to the `/verify` endpoint of the `facilitator server`.
6. `Facilitator server` performs verification of the object based on the `scheme` and `networkId` of the `Payment Payload` and returns a `Verification Response`
7. If the `Verification Response` is valid, the resource server performs the work to fulfill the request. If the `Verification Response` is invalid, the resource server returns a `402 Payment Required` status and a `Payment Required Response` JSON object in the response body.
8. `Resource server` either settles the payment by interacting with a blockchain directly, or by POSTing the `Payment Payload` and `Payment Details` to the `/settle` endpoint of the `facilitator server`.
9. `Facilitator server` submits the payment to the blockchain based on the `scheme` and `networkId` of the `Payment Payload`.
10. `Facilitator server` waits for the payment to be confirmed on the blockchain.
11. `Facilitator server` returns a `Payment Execution Response` to the resource server.
12. `Resource server` returns a `200 OK` response to the `Client` with the resource they requested as the body of the HTTP response, and a `X-PAYMENT-RESPONSE` header containing the `Settlement Response` as Base64 encoded JSON if the payment was executed successfully.

### Summary

The facilitator acts as an independent verification and settlement layer within the x402 protocol. It helps servers confirm payments and submit transactions onchain without requiring direct blockchain infrastructure.

Next, explore:

* [Client / Server ](https://x402.gitbook.io/x402/core-concepts/client-server)— understand the roles and responsibilities of clients and servers
* [HTTP 402](https://x402.gitbook.io/x402/core-concepts/http-402) — understand how payment requirements are communicated to clients

# Wallet

This page explains the role of the **wallet** in the x402 protocol.

In x402, a wallet is both a payment mechanism and a form of unique identity for buyers and sellers. Wallet addresses are used to send, receive, and verify payments, while also serving as identifiers within the protocol.

### Role of the Wallet

#### For Buyers

Buyers use wallets to:

* Store USDC/crypto
* Sign payment payloads
* Authorize onchain payments programmatically

Wallets enable buyers, including AI agents, to transact without account creation or credential management.

#### For Sellers

Sellers use wallets to:

* Receive USDC/crypto payments
* Define their payment destination within server configurations

A seller's wallet address is included in the payment requirements provided to buyers.

[CDP's Wallet API ](https://docs.cdp.coinbase.com/wallet-api-v2/docs/welcome)is our recommended option for programmatic payments and secure key management.

### Summary

* Wallets enable programmatic, permissionless payments in x402.
* Buyers use wallets to pay for services.
* Sellers use wallets to receive payments.
* Wallet addresses also act as unique identifiers within the protocol.

# Bazaar (Discovery Layer)

The x402 Bazaar is the discovery layer for the x402 ecosystem - a machine-readable catalog that helps developers and AI agents find and integrate with x402-compatible API endpoints. Think of it as a search index for payable APIs, enabling the autonomous discovery and consumption of services.

The x402 Bazaar is in early development. While our vision is to build the "Google for agentic endpoints," we're currently more like "Yahoo search" - functional but evolving. Features and APIs may change as we gather feedback and expand capabilities.

### Overview

The Bazaar solves a critical problem in the x402 ecosystem: **discoverability**. Without it, x402-compatible endpoints are like hidden stalls in a vast market. The Bazaar provides:

* **For Buyers (API Consumers)**: Programmatically discover available x402-enabled services, understand their capabilities, pricing, and schemas
* **For Sellers (API Providers)**: Automatic visibility for your x402-enabled services to a global audience of developers and AI agents
* **For AI Agents**: Dynamic service discovery without pre-baked integrations - query, find, pay, and use

### How It Works

The Bazaar currently provides a simple `/list` endpoint that returns all x402-compatible services registered with the CDP facilitator. Services are automatically opted-in when they use the CDP facilitator, making discovery frictionless for sellers.

**Note:** While a discovery layer is live today for the CDP Facilitator, the spec for the marketplace items is open and part of the x402 scheme, meaning any facilitator can create their own discovery layer.&#x20;

#### Basic Flow

1. **Discovery**: Clients query the `/list` endpoint to find available services
2. **Selection**: Choose a service based on price, capabilities, and requirements
3. **Execution**: Use x402 to pay for and access the selected service
4. **No Manual Setup**: No API keys, no account creation, just discover and pay

### API Reference

#### List Endpoint

Retrieve all available x402-compatible endpoints:

```bash
GET https://api.cdp.coinbase.com/platform/v2/x402/discovery/resources
```

**Note**: the recommended way to use this endpoint is to use the `useFacilitator` hook as described below.

**Response Schema**

Each endpoint in the list contains the following fields:

```json
{
      "accepts": [
        {
          "asset": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // ERC-20 token contract address accepted for payment (here, USDC on Base)
          "description": "", // Optional description of the accepted payment
          "extra": {
            "name": "USD Coin", // Human-readable name of the asset
            "version": "2" // Version of the asset, if applicable
          },
          "maxAmountRequired": "200", // Maximum amount (in atomic units, e.g USDC has 6 decimals) required for the service
          "maxTimeoutSeconds": 60, // Maximum time (in seconds) the service will wait for payment before expiring
          "mimeType": "", // Expected MIME type for the response (optional/empty if not specified)
          "network": "base", // network where payment is accepted (e.g., 'base' for Base L2)
          "outputSchema": {
            "input": {
              "method": "GET", // HTTP method to use when calling the resource
              "type": "http" // Type of resource (e.g., 'http' endpoint)
            },
            "output": null // Output schema (null if not specified)
          },
          "payTo": "0xa2477E16dCB42E2AD80f03FE97D7F1a1646cd1c0", // Address to which payment should be sent
          "resource": "https://api.example.com/x402/last_sold", // The actual API endpoint/resource URL
          "scheme": "exact" // Payment scheme (e.g., 'exact' means exact amount required)
        }
      ],
      "lastUpdated": "2025-08-09T01:07:04.005Z", 
      "metadata": {}, // Additional metadata about the service (empty object if none)
      "resource": "https://api.prixe.io/x402/last_sold", // The main resource URL for this service
      "type": "http", 
      "x402Version": 1 // Version of the x402 protocol supported
    },
```

### Quickstart for Buyers

See the full example here for [Python](https://github.com/coinbase/x402/tree/main/examples/python/discovery) and [Node.js](https://github.com/coinbase/x402/tree/main/examples/typescript/discovery).

#### Step 1: Discover Available Services

Fetch the list of available x402 services using the facilitator client:

Typescript:

```typescript
import { useFacilitator } from "x402/verify";
import { facilitator } from "@coinbase/x402";


const { list } = useFacilitator(facilitator);

// Fetch all available services
const services = await list();

// NOTE: in an MCP context, you can see the full list then decide which service to use

// Find services under $0.10
const usdcAsset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
const maxPrice = 100000;

const affordableServices = services.items.filter(item => item.accepts.find(paymentRequirements => paymentRequirements.asset == usdcAsset && Number(paymentRequirements.maxAmountRequired) < maxPrice));
```

Python:

```python
from x402.facilitator import FacilitatorClient, FacilitatorConfig
from cdp.x402 import create_facilitator_config

# Set up facilitator client
facilitator_config = create_facilitator_config()
facilitator = FacilitatorClient(facilitator_config)

# Fetch all available services
services = await facilitator.list()

# NOTE: in an MCP context, you can see the full list then decide which service to use

# Find services under $0.10
usdc_asset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
max_price = 100000

affordable_services = [
  item
  for item in services.items
  if any(
    payment_req.asset == usdc_asset
    and int(payment_req.max_amount_required) < max_price
    for payment_req in item.accepts
   )
  ]
```

#### Step 2: Call a Discovered Service

Once you've found a suitable service, use an x402 client to call it:

Typescript:

```typescript
import { withPaymentInterceptor } from 'x402-axios'; 
import axios from 'axios'; 
import { privateKeyToAccount } from 'viem/accounts';

// Set up your payment account
const account = privateKeyToAccount('0xYourPrivateKey');

// Select a service from discovery
const selectedService = affordableServices[0];

// Create a payment-enabled client for that service
const client = withPaymentInterceptor(
  axios.create({ baseURL: selectedService.endpoint }), 
  account
);

// Select the payment method of your choice
const selectedPaymentRequirements = selectedService.accepts[0];
const inputSchema = selectedPaymentRequirements.outputSchema.input;

// Build the request using the service's schema
const response = await client.request({
  method: inputSchema.method,
  url: inputSchema.resource,
  params: { location: 'San Francisco' } // Based on inputSchema
});

console.log('Response data:', response.data);
```

Python:&#x20;

```python
from x402.client import X402Client
from eth_account import Account

# Set up your payment account
account = Account.from_key('0xYourPrivateKey')
client = X402Client(account)

# Select a service from discovery
selected_service = affordable_services[0]

# Select the payment method of your choice
selected_payment_requirements = selected_service.accepts[0]
input_schema = selected_payment_requirements.output_schema.input

# Make the request
response = client.request({
    method=input_schema.method,
    url=input_schema.resource,
    params={ "location": "San Francisco" } # Based on input_schema
})

print(f"Response data: {response}")
```

### Quickstart for Sellers

#### Automatic Listing with Discoverable Flag

If your API uses the latest version of the CDP facilitator for x402 payments, it's **ingested in the bazaar if you make the `discoverable` flag true in the input schema (see below).**

#### Adding Metadata

To enhance your listing with descriptions and schemas, include them when setting up your x402 middleware. **You should include descriptions for each parameter to make it clear for the agent to call your endpoints**:

Typescript:&#x20;

<pre><code>// Next.js / Express / Hono
 
import { require402Payment } from 'x402-express';
<strong>
</strong><strong>app.use(require402Payment({
</strong>  routes: {
    "/api/weather": {
      price: "$0.001",
      network: "base",
      config: {
        discoverable: true, // make your endpoint discoverable
        description: "Get current weather data for any location",
        inputSchema: { 
          queryParams: { 
            location: { 
              type: string, 
              description: "City name or coordinates", 
              required: true
            }
          }
        },
        outputSchema: {
          type: "object",
          properties: { 
            temperature: { type: "number" },
            conditions: { type: "string" },
            humidity: { type: "number" }
          }
        }
      }
    }
  }
}));
</code></pre>

Python &#x20;

<pre><code># FastAPI / Flask

from x402 import require_payment

<strong>app.middleware("http")(
</strong>    require_payment(
        path="/weather",
        price="$0.001",
        pay_to_address=WALLET_ADDRESS,
        network="base",
        description="Get current weather data for any location",
        discoverable=true, # make your endpoint discoverable &#x3C;----
        input_schema={
            "queryParams": {
                "location": {
                    "type": string,
                    "description": "City name or coordinates",
                    "required": true
                }
            }
        },
        output_schema={
            "type": "object",
            "properties": {
                "temperature": {"type": "number"},
                "conditions": {"type": "string"},
                "humidity": {"type": "number"}
            }
        }
    )
)
```
</code></pre>

### Coming Soon

The x402 Bazaar is rapidly evolving, and your feedback helps us prioritize features.

### Support

* **GitHub**: [github.com/coinbase/x402](https://github.com/coinbase/x402)
* **Discord**: [Join #x402 channel](https://discord.com/invite/cdp)
* **Documentation**: x402 Overview

### FAQ

**Q: How do I get my service listed?** A: If you're using the CDP facilitator, your service is listed once you include the discoverable flag

**Q: How can I make endpoint calls more accurate?** Include descriptions clearly stating what each parameter does and how to call your endpoint, but do so as succinctly as possible.

**Q: How does pricing work?** A: Listing is free. Services set their own prices per API call, paid via x402.

**Q: What networks are supported?** A: Currently Base (mainnet) with USDC payments.

**Q: Can I list non-x402 services?** A: No, only x402-compatible endpoints can be listed. See our seller quickstart to make your API x402-compatible.

# Network & Token Support

This page explains which blockchain networks and tokens are supported by x402, and how to extend support to additional networks.

## Overview

x402 is designed to work across multiple blockchain networks, with different levels of support depending on the facilitator being used. The protocol itself is network-agnostic, but facilitators need to implement network-specific logic for payment verification and settlement.

### Supported Facilitators

Network support in x402 depends on which facilitator you use. Here are the currently available facilitators:

#### x402.org Facilitator

* **Supports**: Base Sepolia, Solana Devnet
* **Notes**: Recommended for testing and development. This is the default facilitator in the x402 packages and requires no setup.
* **URL**: <https://x402.org/facilitator>

#### CDP's x402 Facilitator

* **Supports**: Base, Base Sepolia, Solana, Solana Devnet
* **Notes**: Production-ready for mainnet payments with KYT/OFAC compliance checks. Can also be used for testing on Base Sepolia. Requires CDP API keys. Uses facilitator object instead of facilitator URL.
* **Requirements**: CDP account and API keys from [cdp.coinbase.com](https://cdp.coinbase.com), see Quickstart for Sellers: Running on Mainnet for more details.

#### x402.rs Facilitator

* **Supports**: Base Sepolia, Base, XDC Mainnet
* **Notes**: Rust-based facilitator operated by the x402 community.
* **URL**: <https://facilitator.x402.rs>

#### PayAI Facilitator

* **Supports**: Solana, Base, Polygon, Avalanche, Sei, Peaq, Iotex and all of their testnets.
* **Notes**: Production-ready for mainnet payments. Supports all tokens on Solana, supports EIP-3009 tokens on EVM-Based chains.
* **URL**: <https://facilitator.payai.network>

#### Self-Hosted Facilitators

* **Supports**: Any EVM network
* **Notes**: Run your own facilitator for full control and customization. Supports networks like Avalanche, Polygon, Arbitrum, and other EVM-compatible chains.
* **Setup**: See "Adding Support for New Networks" section below

#### Third-Party Facilitators

Additional facilitators may be available from external providers. Check the [x402 Discord community](https://discord.gg/cdp) for the latest facilitator offerings.

### Token Support

x402 supports tokens on both EVM and Solana networks:

* **EVM**: Any ERC-20 token that implements the EIP-3009 standard
* **Solana**: Any SPL or token-2022 token

**Important**: Facilitators support networks, not specific tokens — any EIP-3009 compatible token works on EVM networks, and any SPL/token-2022 token works on Solana, for the facilitators that support those networks.

#### EVM: EIP-3009 Requirement

Tokens must implement the `transferWithAuthorization` function from the EIP-3009 standard. This enables:

* **Gasless transfers**: The facilitator sponsors gas fees
* **Signature-based authorization**: Users sign transfer authorizations off-chain
* **Secure payments**: Transfers are authorized by cryptographic signatures

#### Specifying Payment Amounts

When configuring payment requirements, you have two options:

1. **Price String** (e.g., `"$0.01"`) - The system infers USDC as the token
2. [**TokenAmount**](https://github.com/coinbase/x402/blob/094dcd2b95b5e13e8673264cc026d080417ee142/typescript/packages/x402/src/types/shared/middleware.ts#L28) - Specify exact atomic units of any EIP-3009 token

#### Using Custom EIP-3009 Tokens

To use a custom EIP-3009 token, you need three key pieces of information:

1. **Token Address**: The contract address of your EIP-3009 token
2. **EIP-712 Name**: The token's name for EIP-712 signatures
3. **EIP-712 Version**: The token's version for EIP-712 signatures

**Finding Token Information on Basescan**

You can retrieve the required EIP-712 values from any block explorer:

1. **Name**: Read the `name()` function - [Example on Basescan](https://basescan.org/token/0x833589fcd6edb6e08f4c7c32d4f71b54bda02913#readProxyContract#F16)
2. **Version**: Read the `version()` function - [Example on Basescan](https://basescan.org/token/0x833589fcd6edb6e08f4c7c32d4f71b54bda02913#readProxyContract#F24)

These values are used in the `eip712` nested object when configuring TokenAmount:

```typescript
{
  eip712: {
    name: "USD Coin",    // From name() function
    version: "2"         // From version() function
  }
}
```

#### Solana: SPL Tokens & Token 2022 Tokens

On Solana, x402 supports all SPL tokens and Token 2022 tokens. When using facilitators that support Solana or Solana Devnet, payments can be made in any SPL/token-2022 token, including USDC (SPL). No EIP-712 configuration is required on Solana.

#### USDC - The Default Token

* **Status**: Supported by default across all networks
* **Why**: USDC implements EIP-3009 and is widely available
* **Networks**: Available on Base, Base Sepolia, and all supported networks

#### Why EIP-3009?

The EIP-3009 standard is essential for x402 because it enables:

1. **Gas abstraction**: Buyers don't need native tokens (ETH, MATIC, etc.) for gas
2. **One-step payments**: No separate approval transactions required
3. **Universal facilitator support**: Any EIP-3009 token works with any facilitator

### Quick Reference

| Facilitator       | Networks Supported                                                                                                         | Production Ready | Requirements    |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------- | --------------- |
| x402.org          | base-sepolia, solana-devnet                                                                                                | ❌ Testnet only   | None            |
| CDP Facilitator   | base, base-sepolia, solana, solana-devnet                                                                                  | ✅                | CDP API keys    |
| x402.rs           | base-sepolia, base, xdc                                                                                                    | ✅                | None            |
| PayAI Facilitator | solana, solana-devnet, base, base-sepolia, polygon, polygon-amoy, avalanche, avalanche-fuji, sei, sei-testnet, peaq, iotex | ✅                | None            |
| Self-hosted       | Any EVM network                                                                                                            | ✅                | Technical setup |

**Note**: On EVM networks, facilitators support any EIP-3009 compatible token; on Solana, facilitators support any SPL/Token-2022 token.

### Adding Support for New Networks

There are two ways to add support for new EVM networks in x402:

#### Option 1: Contributing to x402 Packages

You can add official network support by submitting a PR to the x402 repository. This makes your network available to all x402 users.

**Files to Modify**

1. **`typescript/packages/x402/src/types/shared/evm/config.ts`**

   Add your network's chain ID and USDC address:

   ```typescript
   // Example: Adding Avalanche networks
   "43113": {  // Avalanche Fuji testnet chain ID
     usdcAddress: "0x5425890298aed601595a70AB815c96711a31Bc65",
     usdcName: "USD Coin",
   },
   "43114": {  // Avalanche mainnet chain ID
     usdcAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
     usdcName: "USDC",
   },
   ```
2. **`typescript/packages/x402/src/types/shared/network.ts`**

   Add your network to the schema and mappings:

   ```typescript
   // Update the NetworkSchema enum
   export const NetworkSchema = z.enum(["base-sepolia", "base", "avalanche-fuji", "avalanche"]);

   // Add to SupportedEVMNetworks array
   export const SupportedEVMNetworks: Network[] = [
     "base-sepolia",
     "base",
     "avalanche-fuji",
     "avalanche",
   ];

   // Add to EvmNetworkToChainId mapping
   ["avalanche-fuji", 43113],
   ["avalanche", 43114],
   ```
3. **`typescript/packages/x402/src/types/shared/evm/wallet.ts` - Update `getChainFromNetwork` function**

   Add your network to the `getChainFromNetwork` function to map your network string to the viem chain object:

   ```typescript
   import { avalanche, avalancheFuji } from "viem/chains";

   // Add your network to the switch statement in getChainFromNetwork
   case "avalanche":
     return avalanche;
   case "avalanche-fuji":
     return avalancheFuji;
   ```

**Key Requirements**

* **Network key**: Use a consistent network identifier (e.g., `avalanche-fuji`) across all files
* **Viem chain**: Your network must be available in viem/chains or you'll need to define it manually
* **USDC address**: Must be EIP-3009 compatible (has `transferWithAuthorization` function)
* **Chain ID**: Use your network's official chain ID in the config
* **Consistency**: Ensure the network name matches across `NetworkSchema`, `SupportedEVMNetworks`, `EvmNetworkToChainId`, and the `getChainFromNetwork` switch statement

#### Option 2: Running Your Own Facilitator

If you need immediate support or want to test before contributing, you can run your own facilitator.

Video Guide: [Adding EVM Chains to x402](https://x.com/jaycoolh/status/1920851551905575164/video/1)

**Prerequisites**

1. Access to an RPC endpoint for your target network
2. A wallet with native tokens for gas sponsorship
3. The x402 facilitator code

### Future Network Support

The x402 ecosystem is actively expanding network support. Planned additions include:

* Additional L2 networks
* Additional non-EVM chain support
* Cross-chain payment capabilities


# MCP Server with x402

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/) is a protocol for passing context between LLMs and other AI agents. This page shows how to use the x402 payment protocol with MCP to make paid API requests through an MCP server, and how to connect it to Claude Desktop.

### What is this integration?

This guide walks you through running an MCP server that can access paid APIs using the x402 protocol. The MCP server acts as a bridge between Claude Desktop (or any MCP-compatible client) and a paid API (such as the sample weather API in the x402 repo). When Claude (or another agent) calls a tool, the MCP server will:

1. Detect if the API requires payment (via HTTP 402)
2. Automatically handle the payment using your wallet
3. Return the paid data to the client (e.g., Claude)

This lets you (or your agent) access paid APIs programmatically, with no manual payment steps.

***

### Prerequisites

* Node.js (v20 or higher)
* An x402-compatible server to connect to (for this demo, we'll use the [sample express server with weather data](https://github.com/coinbase/x402/tree/main/examples/typescript/servers/express) from the x402 repo, or any external x402 API)
* An Ethereum wallet with USDC (on Base Sepolia or Base Mainnet), or a Solana wallet with USDC (on Solana Devnet or Solana)
* [Claude Desktop with MCP support](https://claude.ai/download)

***

### Step-by-Step: Build the MCP + x402 Integration

You can find a ready-to-use version of this code in the [x402 repo](https://github.com/coinbase/x402/tree/main/examples/typescript/mcp). Below, we explain each step so you understand how it works and can adapt it to your needs.

#### 1. Install Dependencies

```bash
npm install @modelcontextprotocol/sdk axios viem x402-axios dotenv
```

#### 2. Set Up Environment Variables

Create a `.env` file in your project root:

```env
PRIVATE_KEY=0xYourTestnetPrivateKey
RESOURCE_SERVER_URL=http://localhost:4021
ENDPOINT_PATH=/weather
```

* `PRIVATE_KEY`: Your EVM wallet's private key (for signing payments)
* `RESOURCE_SERVER_URL`: The base URL of the paid API (use the sample express server for this demo)
* `ENDPOINT_PATH`: The specific endpoint path (e.g., `/weather`)

#### 3. Implementation: MCP Server with x402 Payments

```js
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import axios from "axios";
import { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { withPaymentInterceptor } from "x402-axios";
import { config } from "dotenv";

// Load environment variables and throw an error if any are missing
config();

const privateKey = process.env.PRIVATE_KEY as Hex;
const baseURL = process.env.RESOURCE_SERVER_URL as string; // e.g. https://example.com
const endpointPath = process.env.ENDPOINT_PATH as string; // e.g. /weather

if (!privateKey || !baseURL || !endpointPath) {
  throw new Error("Missing environment variables");
}

// Create a wallet client to handle payments
const account = privateKeyToAccount(privateKey);

// Create an axios client with payment interceptor using x402-axios
const client = withPaymentInterceptor(axios.create({ baseURL }), account);

// Create an MCP server
const server = new McpServer({
  name: "x402 MCP Client Demo",
  version: "1.0.0",
});


// Add an addition tool
server.tool(
  "get-data-from-resource-server",
  "Get data from the resource server (in this example, the weather)", //change this description to change when the client calls the tool
  {},
  async () => {
    const res = await client.get(endpointPath);
    return {
      content: [{ type: "text", text: JSON.stringify(res.data) }],
    };
  },
);

const transport = new StdioServerTransport();
await server.connect(transport);
```

**How it works**

* The MCP server exposes a tool that, when called, fetches data from a paid API endpoint.
* If the endpoint requires payment, the x402-axios interceptor handles the payment handshake using your wallet.
* Once payment is complete, the data is returned to the MCP client (e.g., Claude Desktop).

***

### Add the MCP Server to Claude Desktop

To use this integration with Claude Desktop:

1. Open Claude Desktop and go to MCP settings.
2. Add a new MCP server with the following config (adjust paths as needed):

```json
{
  "mcpServers": {
    "demo": {
      "command": "pnpm",
      "args": [
        "--silent",
        "-C",
        "<absolute path to this repo>/examples/typescript/clients/mcp",
        "dev"
      ],
      "env": {
        "PRIVATE_KEY": "<private key of a wallet with USDC on Base Sepolia>",
        "RESOURCE_SERVER_URL": "http://localhost:4021",
        "ENDPOINT_PATH": "/weather"
      }
    }
  }
}
```

3. Make sure your x402-compatible server (e.g., the sample express server) is running and accessible at the URL you provided.
4. Start the MCP client (e.g., with `pnpm dev` in the client directory).
5. Claude can now call the tool and receive paid data!

***

### How the Pieces Fit Together

* **x402-compatible server**: Hosts the paid API (e.g., weather data). Responds with HTTP 402 if payment is required.
* **MCP server (this implementation)**: Acts as a bridge, handling payment and exposing tools to MCP clients.
* **Claude Desktop**: Calls the MCP tool, receives the paid data, and displays it to the user.

***

### Next Steps

* [See the full example in the repo](https://github.com/coinbase/x402/tree/main/examples/typescript/mcp)
* Try integrating with your own x402-compatible APIs
* Extend the MCP server with more tools or custom logic as needed


### Getting Help

For help with network integration:

* Join the [x402 Discord community](https://discord.gg/cdp)
* Check the [x402 GitHub repository](https://github.com/coinbase/x402)

### Summary

x402's network support is designed to be extensible while maintaining security and reliability. Whether you're using the default Base Sepolia setup for testing or running your own facilitator for custom networks, the protocol provides flexibility for various use cases.

Key takeaways:

* Base and Base Sepolia have the best out-of-the-box support
* Any EVM network can be supported with a custom facilitator
* Any EIP-3009 token (with `transferWithAuthorization`) works on any facilitator
* Use price strings for USDC or TokenAmount for custom tokens
* Network choice affects gas costs and payment economics

Next, explore:

* Quickstart for Sellers — Start accepting payments on supported networks
* Core Concepts — Learn how x402 works under the hood
* Facilitator — Understand the role of facilitators
* MCP Server — Set up AI agents to use x402 payments
